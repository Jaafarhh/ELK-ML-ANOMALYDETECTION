# This pipeline receives log lines via TCP, parses them as CSV,
# processes the fields, and sends them to Elasticsearch.

input {
  tcp {
    port => 5045 # Port the Python script will send data to
    codec => line { charset => "UTF-8" } # Treat each line as a separate event
  }
}

filter {
  # Use Grok to parse the line.
  # The IdProcess pattern ([^,]*) now allows zero or more non-comma characters.
  grok {
    match => { "message" => "^%{TIMESTAMP_ISO8601:Date},(?<Hostname>[^,]+),(?<Process>[^,]+),(?<IdProcess>[^,]*),%{GREEDYDATA:Message}$" }
    overwrite => [ "message" ]
  }

  # Check if Grok failed (e.g., line was completely malformed like ",,,,")
  if "_grokparsefailure" in [tags] {
    # Tag the event for investigation
    mutate {
      add_tag => ["_grokparsefailure_investigate"]
      # Optionally remove the original message if it's just noise like ",,,,"
      # if [message] =~ /^,+$/ {
      #   remove_field => ["message"]
      # }
    }
    # We are NOT dropping these lines anymore, just tagging them.
  } else {
    # --- Post-processing for successful grok matches ---

    # If IdProcess was captured as an empty string, replace it with "N/A"
    if ![IdProcess] or [IdProcess] == "" {
      mutate {
        replace => { "IdProcess" => "N/A" }
      }
    }

    # Perform cleanup and type conversion
    mutate {
      # Strip leading/trailing whitespace and quotes from the captured Message
      strip => ["Message"]
      gsub => [
        "Message", "^\"|\"$", "" # Remove leading/trailing double quotes
      ]

      # Remove fields we don't need
      # Keep 'host' from tcp input temporarily
      remove_field => ["message", "log", "agent", "ecs", "input", "Date", "@version", "event", "[@metadata]"]

      # Ensure IdProcess is treated as string
      convert => { "IdProcess" => "string" }

      # Rename fields to be more ECS compliant
      rename => {
          "Hostname" => "host.name"
          "Process" => "process.name"
          "IdProcess" => "process.pid_string"
      }
      # Add success tag
      add_tag => ["linux_log_simulated_grok_ok"]
    }

    # If the process name contains a path, extract just the executable name
    if [process.name] and "/" in [process.name] {
      grok {
        match => { "process.name" => "(?:.*\/)?(?<process.executable>[^/]+)$" }
        overwrite => [ "process.executable" ]
      }
    }

    # Remove the 'host' field added by the TCP input if it's not the same as host.name
    if [host] and [host][name] != [host.name] {
        mutate { remove_field => ["host"] }
    }
  } # <-- End of else block for successful grok
} # <-- End of filter block

output {
  # Send the processed data to Elasticsearch
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "linux-logs-%{+YYYY.MM.dd}"
  }

  # (Optional) Print processed events to Logstash console for debugging
  # stdout { codec => rubydebug }
}